# Фундаментальные недостатки Avalonia UI

Стоит заметить, что Avalonia UI соответствует современным подходам к созданию Desktop-приложений, реализуя, в частности, шаблон проектирования MVVM. Клюевой особенностью шаблона MVVM является разделение уровней представления (View), доступа к данным (Model) и управляющего слоя (ViewModel).

В общем случае, View описывается декларативно на XAML - элементы пользовательского интерфейса существуют всегда, но могут быть невидимы. Программист не управляет жизненным циклом элементов пользовательского интерфейса, но управляет режимами визуализации. Стоит сказать о том, что попытки управления жизненным циклом элементов пользовательского интерфейса чаще всего являются причиной огромного количества ошибок и исключительно низкой надёжность приложений. Более того, сопровождать приложения, в которых элементы пользовательского интерфейса появляются и исчезают хаотично - крайне сложная задача.

Model решает задачи доступа к данным, предоставляя фасад (Facade). Поскольку доступ к данным может быть связан с блокирующими операциями ввода/вывода, код за фасадом может быть достаточно сложным и это, определённо, та часть кода, которую следует изолировать, дабы избежать сложного поведения пользовательского интерфейса.

ViewModel - управляющий слой, который изменяет свойства, используемые при рендеринге пользовательского интерфейса и обращается к Model с целью получения, или обновления имеющихся в нём данных.

Однако, и сам подход MVVM, и его реализация в Avalonia UI содержит ряд недостатков, которые требуют добавления компенсационных мер, местами приводящих к значительному усложнению кода. В ряде случаев, недостатки являются принципиально не устраняемыми.

## Однопоточный рендеринг

Рендеринг контента всегда осуществляется в одном потоке исполнения. Это значит, что даже если ваш процессор содержит 8 аппаратных ядер, то при рендеринге изображения, будет задействованно только одно ядро. Если композиция пользовательского интерфейса сложная, или содержит большое количество элементов, это может приводить к задержкам в реакции пользовательского интерфейса на действия пользователя, что означает ухудшение пользовательского опыта.

С целью ускорения рендеринга в Avalonia UI были добавлены **CompileBindings**, позволяющие снизить потребность в применении Reflection при выполнении приложения, переместив задачу привязки свойств элементов пользовательского интерфейса на этап компиляции. Следует стараться использовать этот механизм, который "по умолчанию" не используется.

## Передача списков через ObservableCollection

Предположим, что в DataGrid мы хотим выделять некоторым цветом красным строки в которых значение поля "Error" не нулевое. У каждой строки есть атрибут **Classes**, который содержит набор классов, используемых для управления визуализацией. Заметим, что в MVVM мы указываем органу управления "таблица" источник данных. В случае Avalonia - мы выполняем связывание DataGrid и ObservableCollection. Теоретически, мы могли бы создать в источнике данных поле Classes и связать его с атрибутом Classes у строки. В этом случае, мы бы выделяли нужным цветом строку без каких-либо сложных модификаций - мы бы просто учитывали бы данные из модели при формировании ObservableCollection. Однако, так сделать в Avalonia нельзя.

Альтернативные решения: TypeConverter, собственная реализация атрибута **LoadingRow**, либо Avalonia.Xaml.Behaviors. Исходя из моего опыта, работоспособным оказался только вариант с атрибутом **LoadingRow** - остальные варианты либо не работают, либо глючат. В любом случае, эти варанты создают потреность в костылях, которые усложняют код и нарушают "чистоту" концепции MVVM.

Update: возможно, что [Binding Classes](https://docs.avaloniaui.net/docs/data-binding/binding-classes) эту проблему решают.
